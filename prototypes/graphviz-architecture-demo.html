<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Graphviz Architecture Diagram Demo</title>
    <style>
      body {
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
        background: #f5f5f5;
      }
      h1 {
        color: #333;
      }
      .diagram-container {
        background: white;
        border-radius: 8px;
        padding: 1rem;
        margin: 1rem 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      #architecture-diagram {
        width: 100%;
        min-height: 600px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: white;
      }
      .code-block {
        background: #1e1e1e;
        color: #d4d4d4;
        padding: 1rem;
        border-radius: 4px;
        overflow-x: auto;
        font-family: "Monaco", "Courier New", monospace;
        font-size: 0.875rem;
        margin: 1rem 0;
      }
      button {
        background: #007acc;
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.875rem;
        margin-right: 0.5rem;
      }
      button:hover {
        background: #005a9e;
      }
      .controls {
        margin: 1rem 0;
      }
      .component-info {
        background: white;
        border-radius: 8px;
        padding: 1rem;
        margin: 1rem 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .component-info h3 {
        margin-top: 0;
        color: #333;
      }
      .component-info #component-details {
        font-family: monospace;
        font-size: 0.875rem;
      }
    </style>
    <!-- Using Viz.js with full.render.js (required for browser usage) -->
    <script src="https://unpkg.com/viz.js@2.1.2/viz.js"></script>
    <script src="https://unpkg.com/viz.js@2.1.2/full.render.js"></script>
  </head>
  <body>
    <h1>Graphviz Architecture Diagram Demo</h1>
    <p>
      This example shows how to use <code>ts-graphviz</code> (or manual DOT
      generation) to create and render architecture diagrams in the browser.
    </p>

    <div class="controls">
      <button onclick="renderExample1()">Layered Architecture</button>
      <button onclick="renderExample2()">Microservices Architecture</button>
      <button onclick="renderExample3()">Component Diagram</button>
    </div>

    <div class="diagram-container">
      <div id="architecture-diagram"></div>
    </div>

    <div id="component-info" class="component-info" style="display: none">
      <h3>Component Details</h3>
      <div id="component-details"></div>
    </div>

    <h2>Generated DOT Code</h2>
    <pre class="code-block" id="dot-code"></pre>

    <script>
      // Wait for Viz.js and full.render.js to load
      window.addEventListener("load", function () {
        // Wait a bit longer for full.render.js to initialize Module and render
        setTimeout(function () {
          // Check what's available
          console.log("Viz:", typeof Viz);
          console.log("Module:", typeof Module);
          console.log("render:", typeof render);

          // Try to create instance early to catch any errors
          const viz = getVizInstance();
          if (viz) {
            console.log("Viz instance ready");
          } else {
            console.warn(
              "Could not create Viz instance yet, will retry on render",
            );
          }

          // Render initial example
          if (typeof renderExample1 === "function") {
            renderExample1();
          }
        }, 500); // Give more time for full.render.js to load
      });

      // For this browser demo, we'll generate DOT strings manually
      // In a real TypeScript project with ts-graphviz, you'd import and use the library

      // Example: Layered Architecture
      function generateLayeredArchitectureDot() {
        return `digraph layered_architecture {
        rankdir=TB;
        node [shape=box, style=rounded];
        
        // Presentation Layer
        subgraph cluster_presentation {
          label="Presentation Layer";
          style=filled;
          fillcolor="#e1f5ff";
          UI [label="User Interface"];
          API [label="REST API"];
        }
        
        // Application Layer
        subgraph cluster_application {
          label="Application Layer";
          style=filled;
          fillcolor="#fff4e1";
          Service1 [label="Auth Service"];
          Service2 [label="Business Service"];
          Service3 [label="Notification Service"];
        }
        
        // Domain Layer
        subgraph cluster_domain {
          label="Domain Layer";
          style=filled;
          fillcolor="#e1ffe1";
          Domain1 [label="User Domain"];
          Domain2 [label="Product Domain"];
          Domain3 [label="Order Domain"];
        }
        
        // Infrastructure Layer
        subgraph cluster_infrastructure {
          label="Infrastructure Layer";
          style=filled;
          fillcolor="#ffe1f5";
          DB [label="Database"];
          Cache [label="Redis Cache"];
          Queue [label="Message Queue"];
        }
        
        // Connections
        UI -> API;
        API -> Service1;
        API -> Service2;
        API -> Service3;
        Service1 -> Domain1;
        Service2 -> Domain2;
        Service3 -> Domain3;
        Service1 -> DB;
        Service2 -> DB;
        Service2 -> Cache;
        Service3 -> Queue;
      }`;
      }

      // Example: Microservices Architecture
      function generateMicroservicesDot() {
        return `digraph microservices {
        rankdir=LR;
        node [shape=box, style=rounded];
        
        Gateway [label="API Gateway", shape=doubleoctagon, style="rounded,filled", fillcolor="#ffcccc"];
        
        subgraph cluster_frontend {
          label="Frontend";
          WebApp [label="Web App"];
          MobileApp [label="Mobile App"];
        }
        
        subgraph cluster_services {
          label="Microservices";
          UserService [label="User Service", fillcolor="#cce5ff", style="rounded,filled"];
          ProductService [label="Product Service", fillcolor="#cce5ff", style="rounded,filled"];
          OrderService [label="Order Service", fillcolor="#cce5ff", style="rounded,filled"];
          PaymentService [label="Payment Service", fillcolor="#cce5ff", style="rounded,filled"];
        }
        
        subgraph cluster_data {
          label="Data Layer";
          UserDB [label="User DB", shape=cylinder, fillcolor="#ffffcc", style=filled];
          ProductDB [label="Product DB", shape=cylinder, fillcolor="#ffffcc", style=filled];
          OrderDB [label="Order DB", shape=cylinder, fillcolor="#ffffcc", style=filled];
          EventBus [label="Event Bus", shape=doublecircle, fillcolor="#ccffcc", style=filled];
        }
        
        WebApp -> Gateway;
        MobileApp -> Gateway;
        Gateway -> UserService;
        Gateway -> ProductService;
        Gateway -> OrderService;
        OrderService -> PaymentService;
        UserService -> UserDB;
        ProductService -> ProductDB;
        OrderService -> OrderDB;
        UserService -> EventBus;
        ProductService -> EventBus;
        OrderService -> EventBus;
        PaymentService -> EventBus;
      }`;
      }

      // Example: Component Diagram
      function generateComponentDot() {
        return `digraph component_diagram {
        rankdir=TB;
        node [shape=box];
        
        // Main Application
        App [label="Main Application", shape=component, style=filled, fillcolor="#e1f5ff"];
        
        // Core Components
        Router [label="Router Component", shape=component];
        Auth [label="Authentication Component", shape=component, fillcolor="#ffcccc", style=filled];
        Controller [label="Controller Component", shape=component];
        
        // Services
        UserService [label="User Service", shape=folder, fillcolor="#ffffcc", style=filled];
        DataService [label="Data Service", shape=folder, fillcolor="#ffffcc", style=filled];
        
        // External Dependencies
        Database [label="Database", shape=cylinder, fillcolor="#ccffcc", style=filled];
        ExternalAPI [label="External API", shape=box3d, fillcolor="#ffccff", style=filled];
        
        // Connections
        App -> Router;
        Router -> Auth;
        Router -> Controller;
        Controller -> UserService;
        Controller -> DataService;
        UserService -> Database;
        DataService -> ExternalAPI;
        Auth -> UserService;
        
        // Ports (interfaces)
        Router -> Controller [label="routes"];
        Controller -> UserService [label="uses"];
      }`;
      }

      // Make functions globally available
      window.renderExample1 = function () {
        const dot = generateLayeredArchitectureDot();
        renderDot(dot);
      };

      window.renderExample2 = function () {
        const dot = generateMicroservicesDot();
        renderDot(dot);
      };

      window.renderExample3 = function () {
        const dot = generateComponentDot();
        renderDot(dot);
      };

      // Create a single Viz instance
      let vizInstance = null;
      let vizInstancePromise = null;

      function getVizInstance() {
        // Return existing instance if available
        if (vizInstance) {
          return Promise.resolve(vizInstance);
        }

        // Return existing promise if we're already creating one
        if (vizInstancePromise) {
          return vizInstancePromise;
        }

        // Create new promise to initialize Viz
        vizInstancePromise = new Promise(function (resolve, reject) {
          if (typeof Viz === "undefined") {
            reject(new Error("Viz.js not loaded"));
            return;
          }

          // Check if Module and render are available (from full.render.js)
          if (typeof Module !== "undefined" && typeof render !== "undefined") {
            try {
              vizInstance = new Viz({ Module, render });
              console.log("Created Viz instance with Module and render");
              resolve(vizInstance);
              return;
            } catch (error) {
              reject(error);
              return;
            }
          }

          // For file:// protocol, create a blob URL for the worker
          // This allows workers to work with local files
          fetch("https://unpkg.com/viz.js@2.1.2/full.render.js")
            .then(function (response) {
              return response.text();
            })
            .then(function (workerCode) {
              const blob = new Blob([workerCode], {
                type: "application/javascript",
              });
              const workerURL = URL.createObjectURL(blob);
              vizInstance = new Viz({ workerURL });
              console.log("Created Viz instance with blob worker URL");
              resolve(vizInstance);
            })
            .catch(function (error) {
              console.error("Error creating worker from blob:", error);
              reject(error);
            });
        });

        return vizInstancePromise;
      }

      function renderDot(dotString) {
        // Display the DOT code
        document.getElementById("dot-code").textContent = dotString;

        // Check if Viz is available
        if (typeof Viz === "undefined") {
          document.getElementById("architecture-diagram").innerHTML =
            '<div style="padding: 2rem; color: red;">Error: Viz.js not loaded</div>';
          return;
        }

        // Show loading message
        document.getElementById("architecture-diagram").innerHTML =
          '<div style="padding: 2rem; text-align: center;">Rendering diagram...</div>';

        // Get or create Viz instance (async)
        getVizInstance()
          .then(function (viz) {
            // Render using the instance (async)
            return viz.renderString(dotString, {
              format: "svg",
              engine: "dot",
            });
          })
          .then(function (svgString) {
            const container = document.getElementById("architecture-diagram");
            container.innerHTML = svgString;

            // Make the SVG responsive
            const svg = container.querySelector("svg");
            if (svg) {
              svg.style.maxWidth = "100%";
              svg.style.height = "auto";
            }

            // Make nodes clickable
            makeNodesClickable(svg);

            console.log("Diagram rendered successfully");
          })
          .catch(function (error) {
            console.error("Error rendering diagram:", error);
            document.getElementById("architecture-diagram").innerHTML =
              '<div style="padding: 2rem; color: red;">Error rendering diagram: ' +
              error.message +
              "<br><br><strong>Note:</strong> If you're opening this file directly (file://), " +
              "try serving it through a local web server instead:<br>" +
              "<code>python3 -m http.server 8000</code> or <code>npx serve</code></div>";
          });
      }

      // Function to make nodes in the SVG clickable
      function makeNodesClickable(svg) {
        if (!svg) return;

        // Find all node groups (Graphviz creates nodes as <g> elements with class "node")
        const nodes = svg.querySelectorAll("g.node");

        nodes.forEach(function (node) {
          // Make the node visually clickable
          node.style.cursor = "pointer";

          // Get the node label/text
          const textElement = node.querySelector("text");
          const nodeLabel = textElement ? textElement.textContent : "Unknown";

          // Get the shape/polygon element for hover effects
          const shape = node.querySelector("polygon, ellipse, path, rect");

          // Get bounding box of the entire node to create a clickable background
          const bbox = node.getBBox();

          // Create a transparent rectangle that covers the entire node area
          // This makes the whole component clickable, not just the border/text
          const clickableBg = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "rect",
          );
          clickableBg.setAttribute("x", bbox.x - 10); // Add padding for easier clicking
          clickableBg.setAttribute("y", bbox.y - 10);
          clickableBg.setAttribute("width", bbox.width + 20);
          clickableBg.setAttribute("height", bbox.height + 20);
          clickableBg.setAttribute("fill", "transparent");
          clickableBg.setAttribute("stroke", "none");
          clickableBg.setAttribute("pointer-events", "all");
          clickableBg.setAttribute("class", "clickable-bg"); // Mark to exclude from shape queries
          clickableBg.style.cursor = "pointer";

          // Insert the clickable background as the first child (behind everything)
          node.insertBefore(clickableBg, node.firstChild);

          // Store original styles for hover/click effects
          if (shape) {
            // Use a single consistent stroke-width for ALL components
            const CONSISTENT_STROKE_WIDTH = "2";

            // Store original stroke color
            const originalStroke = shape.getAttribute("stroke") || "#000000";

            // Store original text fill color if text element exists
            if (textElement) {
              const originalTextFill =
                textElement.getAttribute("fill") || "#000000";
              // Store original text fill for later restoration
              textElement.setAttribute("data-original-fill", originalTextFill);
            }

            // Set and lock the stroke-width to a consistent value for all components
            shape.setAttribute("stroke-width", CONSISTENT_STROKE_WIDTH);

            // Store on the shape element for later use
            shape.setAttribute("data-original-stroke", originalStroke);
            shape.setAttribute(
              "data-original-stroke-width",
              CONSISTENT_STROKE_WIDTH,
            );

            // Add rounded corners
            if (shape.tagName === "rect") {
              shape.setAttribute("rx", "8");
              shape.setAttribute("ry", "8");
            }
            // Make stroke corners rounded for all shape types
            shape.setAttribute("stroke-linejoin", "round");
            shape.setAttribute("stroke-linecap", "round");

            // Add hover effect - change color ONLY, never change width
            // Text and border must ALWAYS match
            const handleMouseEnter = function () {
              // Only change color if not already selected (not orange)
              const currentStroke = shape.getAttribute("stroke");
              if (currentStroke !== "#ff6600") {
                shape.setAttribute("stroke", "#007acc"); // Blue hover color
                // DO NOT change stroke-width - it stays CONSISTENT_STROKE_WIDTH
                shape.setAttribute("fill-opacity", "0.9");
                // Text must match border - set to same blue
                if (textElement) {
                  textElement.setAttribute("fill", "#007acc"); // Same blue as border
                }
              }
            };

            const handleMouseLeave = function () {
              // Text and border must ALWAYS match
              const currentStroke = shape.getAttribute("stroke");
              if (currentStroke === "#ff6600") {
                // Component is selected - keep text orange to match orange border
                if (textElement) {
                  textElement.setAttribute("fill", "#ff6600"); // Match orange border
                }
              } else {
                // Component is not selected - restore to original colors
                shape.setAttribute("stroke", originalStroke);
                // DO NOT change stroke-width - it stays CONSISTENT_STROKE_WIDTH
                shape.setAttribute("fill-opacity", "1");
                // Text must match border - restore to original
                if (textElement) {
                  const originalTextFill =
                    textElement.getAttribute("data-original-fill") || "#000000";
                  textElement.setAttribute("fill", originalTextFill); // Match original border color
                }
              }
            };

            // Add hover effect to all parts of the component
            clickableBg.addEventListener("mouseenter", handleMouseEnter);
            clickableBg.addEventListener("mouseleave", handleMouseLeave);
            node.addEventListener("mouseenter", handleMouseEnter);
            node.addEventListener("mouseleave", handleMouseLeave);
            // Also attach to the shape itself for hover over the diagram
            if (shape) {
              shape.addEventListener("mouseenter", handleMouseEnter);
              shape.addEventListener("mouseleave", handleMouseLeave);
            }
            // Also attach to text element for hover over labels
            if (textElement) {
              textElement.addEventListener("mouseenter", handleMouseEnter);
              textElement.addEventListener("mouseleave", handleMouseLeave);
            }
          }

          // Add click handler to the background rectangle
          clickableBg.addEventListener("click", function (e) {
            e.stopPropagation();
            handleNodeClick(node, nodeLabel);
          });

          // Add click handler to the node itself (for clicking on shape/text)
          node.addEventListener("click", function (e) {
            e.stopPropagation();
            handleNodeClick(node, nodeLabel);
          });
        });
      }

      // Helper function to handle node clicks
      function handleNodeClick(node, nodeLabel) {
        // Get node details
        const nodeId = node.getAttribute("id") || "unknown";
        const title = node.querySelector("title");
        const titleText = title ? title.textContent : nodeLabel;

        // Display component info
        showComponentInfo({
          id: nodeId,
          label: nodeLabel,
          title: titleText,
          node: node,
        });

        // Highlight the clicked node
        highlightNode(node);

        console.log("Clicked node:", nodeLabel, nodeId);
      }

      // Function to show component information
      function showComponentInfo(info) {
        const infoDiv = document.getElementById("component-info");
        const detailsDiv = document.getElementById("component-details");

        if (!infoDiv || !detailsDiv) return;

        detailsDiv.innerHTML = `
          <strong>ID:</strong> ${info.id}<br>
          <strong>Label:</strong> ${info.label}<br>
          <strong>Title:</strong> ${info.title || "N/A"}<br>
          <strong>Type:</strong> ${info.node.classList.contains("node") ? "Node" : "Unknown"}
        `;

        infoDiv.style.display = "block";
      }

      // Function to highlight a clicked node
      function highlightNode(node) {
        // Helper function to get the actual shape (exclude clickable background)
        // Only select shapes that are NOT the clickable background
        function getActualShape(n) {
          // Query for all potential shape elements
          const shapes = n.querySelectorAll("polygon, ellipse, path, rect");
          // Return the first shape that is NOT the clickable background
          for (let i = 0; i < shapes.length; i++) {
            const shape = shapes[i];
            // Explicitly exclude clickable-bg by checking class and ensuring it's not the transparent background
            if (!shape.classList || !shape.classList.contains("clickable-bg")) {
              // Also check if it's a visible shape (has a visible stroke or fill)
              const fill = shape.getAttribute("fill");
              const stroke = shape.getAttribute("stroke");
              // If it's transparent and has no stroke, it's likely the clickable bg
              if (fill === "transparent" && (!stroke || stroke === "none")) {
                continue; // Skip transparent backgrounds
              }
              return shape;
            }
          }
          return null;
        }

        // Use the same consistent stroke-width for all components
        const CONSISTENT_STROKE_WIDTH = "2";

        // Remove previous highlights from all nodes
        const allNodes = document.querySelectorAll("g.node");
        allNodes.forEach(function (n) {
          const shape = getActualShape(n);
          if (shape) {
            const originalStroke =
              shape.getAttribute("data-original-stroke") || "#000000";
            shape.setAttribute("stroke", originalStroke);
            // NEVER change stroke-width - always use the consistent value
            shape.setAttribute("stroke-width", CONSISTENT_STROKE_WIDTH);
            shape.setAttribute("fill-opacity", "1");
            // Keep rounded corners
            shape.setAttribute("stroke-linejoin", "round");
            shape.setAttribute("stroke-linecap", "round");

            // Text and border must always match - restore text to match border
            const textEl = n.querySelector("text");
            if (textEl) {
              const originalTextFill =
                textEl.getAttribute("data-original-fill") || "#000000";
              textEl.setAttribute("fill", originalTextFill); // Match original border color
            }
          }
        });

        // Highlight clicked node - change color ONLY, never change width
        const shape = getActualShape(node);
        if (shape) {
          // Store original stroke if not already stored
          if (!shape.getAttribute("data-original-stroke")) {
            shape.setAttribute(
              "data-original-stroke",
              shape.getAttribute("stroke") || "#000000",
            );
            shape.setAttribute(
              "data-original-stroke-width",
              CONSISTENT_STROKE_WIDTH,
            );
          }

          // Apply selection highlight - orange border, same width (never change width)
          shape.setAttribute("stroke", "#ff6600"); // Orange for selection
          // NEVER change stroke-width - always use the consistent value
          shape.setAttribute("stroke-width", CONSISTENT_STROKE_WIDTH);
          shape.setAttribute("fill-opacity", "1");

          // Ensure rounded corners
          if (shape.tagName === "rect") {
            shape.setAttribute("rx", "8");
            shape.setAttribute("ry", "8");
          }
          shape.setAttribute("stroke-linejoin", "round");
          shape.setAttribute("stroke-linecap", "round");

          // Text and border must always match - set text to orange to match border
          const textEl = node.querySelector("text");
          if (textEl) {
            // Store original text fill if not already stored
            if (!textEl.getAttribute("data-original-fill")) {
              textEl.setAttribute(
                "data-original-fill",
                textEl.getAttribute("fill") || "#000000",
              );
            }
            textEl.setAttribute("fill", "#ff6600"); // Match orange border color
          }
        }
      }
    </script>

    <h2>Using ts-graphviz in a TypeScript Project</h2>
    <p>
      In a real TypeScript project, you would use <code>ts-graphviz</code> to
      generate DOT, then render with Viz.js:
    </p>
    <pre class="code-block">
// Install: npm install ts-graphviz @ts-graphviz/adapter viz.js

import { digraph, node, edge, attribute, toDot } from 'ts-graphviz';
import Viz from 'viz.js';
import { Module, render } from 'viz.js/full.render.js';

// Create a Viz instance
const viz = new Viz({ Module, render });

// Create diagram programmatically
const G = digraph('architecture', (g) => {
  g.set(attribute.label, 'Layered Architecture');
  g.set(attribute.rankdir, 'TB');
  
  // Create nodes
  const ui = node('UI', {
    [attribute.label]: 'User Interface',
    [attribute.shape]: 'box',
    [attribute.style]: 'rounded'
  });
  
  const api = node('API', {
    [attribute.label]: 'REST API',
    [attribute.shape]: 'box'
  });
  
  const service = node('Service', {
    [attribute.label]: 'Business Service',
    [attribute.shape]: 'box',
    [attribute.style]: 'filled',
    [attribute.fillcolor]: '#fff4e1'
  });
  
  // Add nodes and edges
  g.addNode(ui);
  g.addNode(api);
  g.addNode(service);
  g.addEdge(edge([ui, api]));
  g.addEdge(edge([api, service]));
});

// Convert to DOT string
const dotString = toDot(G);

// Render using Viz.js (no d3 needed!)
const svgString = await viz.renderString(dotString, { format: 'svg', engine: 'dot' });
document.getElementById('diagram').innerHTML = svgString;</pre
    >

    <h2>Alternative: Other Libraries</h2>
    <p>You can also use other libraries instead of Viz.js:</p>
    <ul>
      <li>
        <strong>@hpcc-js/wasm</strong> - Modern WebAssembly-based Graphviz
        (smaller, faster)
      </li>
      <li>
        <strong>Server-side rendering</strong> - Use the Graphviz command-line
        tool on your server
      </li>
      <li>
        <strong>Cytoscape.js</strong> - For interactive graph visualization (you
        already have this!)
      </li>
      <li>
        <strong>Dagre</strong> - For hierarchical layouts (you already have
        this!)
      </li>
    </ul>
  </body>
</html>
